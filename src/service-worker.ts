/// <reference lib='webworker' />
// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
import { clientsClaim } from 'workbox-core'
import {
  cleanupOutdatedCaches,
  createHandlerBoundToURL,
  precacheAndRoute,
} from 'workbox-precaching'
import { NavigationRoute, registerRoute, Route } from 'workbox-routing'
import { NetworkFirst } from 'workbox-strategies'

declare const self: ServiceWorkerGlobalScope

const routesWithoutCaching: Array<string> = ['/logout', '/login', '/api.*']

// We want to publish a new service worker and have it control already-open web pages as soon as it activates
// https://developer.chrome.com/docs/workbox/modules/workbox-core/#clients-claim
clientsClaim()
// Adds an activate event listener which will clean up incompatible precaches that were created by older versions of Workbox.
cleanupOutdatedCaches()

// Precache all the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching.
precacheAndRoute(self.__WB_MANIFEST);

// We serve a single page app, so we use a NavigationRoute to return a specific response for all navigation requests.
// https://developer.chrome.com/docs/workbox/modules/workbox-routing/#how-to-register-a-navigation-route
const handler = createHandlerBoundToURL('./index.html')
const navigationRoute = new NavigationRoute(handler, {
  denylist: routesWithoutCaching.map((route) => new RegExp(route)),
});

registerRoute(navigationRoute)

const networkFirstPaths = [
  '/discipline',
  '/disciplines'
]

const networkFirstRoute = new Route(
  ({ request }) =>
    networkFirstPaths.some((route) => request.url.includes(route)),
  new NetworkFirst({
    cacheName: 'addDisciplineAppData',
  }),
)

registerRoute(networkFirstRoute);

// Skip waiting for activation by default
self.addEventListener('install', () => {
  self.skipWaiting()
});

const cacheName = 'cache-v1';
const resourcesToPrecache = [
  'index.html',
  'logo192.png',
  'logo512.png'
]; // app-shell*

self.addEventListener('install', (event) => {
  console.log('Install triggered!');

  // wait for the last promise
  event.waitUntil(
    caches.open(cacheName)
      .then(cache => cache.addAll(resourcesToPrecache))
  )
});

self.addEventListener('activate', (event) => {
 // old caches can be cleared
 event.waitUntil(
  caches.keys().then((cacheName) => (
    Promise.all(
      cacheName
        .filter(cacheName => cacheName === 'old-cache-to-delete')
        .map((cacheName) => caches.delete(cacheName))
    )
  ))
 )
});

self.addEventListener('fetch', (event) => {
  event.respondWith(caches.match(event.request)
    .then((cachedResponse) => cachedResponse || fetch(event.request)))
});

self.addEventListener('push', (event) => {
  const notificationTitle = 'Soft Uni PWA demo';

  const notification = {
    body: (event as any).data.text(),
    icon: './favicon.ico',
  };

  if (Notification.permission === 'granted') {
    event.waitUntil(
      self.registration.showNotification(notificationTitle, {
          ...notification
        }
      )
    )
  } else {
    // request permission
  }
});
